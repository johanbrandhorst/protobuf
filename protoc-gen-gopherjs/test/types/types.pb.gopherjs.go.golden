// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		TestAllTypes
		NestedTestAllTypes
		ForeignMessage
		TestMap
*/
package types

import jspb "github.com/johanbrandhorst/protobuf/jspb"
import multitest2 "github.com/johanbrandhorst/protobuf/protoc-gen-gopherjs/test/multi"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type ForeignEnum int

const (
	ForeignEnum_FOREIGN_UNSPECIFIED ForeignEnum = 0
	ForeignEnum_FOREIGN_FOO         ForeignEnum = 4
	ForeignEnum_FOREIGN_BAR         ForeignEnum = 5
	ForeignEnum_FOREIGN_BAZ         ForeignEnum = 6
)

var ForeignEnum_name = map[int]string{
	0: "FOREIGN_UNSPECIFIED",
	4: "FOREIGN_FOO",
	5: "FOREIGN_BAR",
	6: "FOREIGN_BAZ",
}
var ForeignEnum_value = map[string]int{
	"FOREIGN_UNSPECIFIED": 0,
	"FOREIGN_FOO":         4,
	"FOREIGN_BAR":         5,
	"FOREIGN_BAZ":         6,
}

func (x ForeignEnum) String() string {
	return ForeignEnum_name[int(x)]
}

type MapEnum int

const (
	MapEnum_MAP_ENUM_FOO MapEnum = 0
	MapEnum_MAP_ENUM_BAR MapEnum = 1
	MapEnum_MAP_ENUM_BAZ MapEnum = 2
)

var MapEnum_name = map[int]string{
	0: "MAP_ENUM_FOO",
	1: "MAP_ENUM_BAR",
	2: "MAP_ENUM_BAZ",
}
var MapEnum_value = map[string]int{
	"MAP_ENUM_FOO": 0,
	"MAP_ENUM_BAR": 1,
	"MAP_ENUM_BAZ": 2,
}

func (x MapEnum) String() string {
	return MapEnum_name[int(x)]
}

type TestAllTypes_NestedEnum int

const (
	TestAllTypes_NESTED_ENUM_UNSPECIFIED TestAllTypes_NestedEnum = 0
	TestAllTypes_FOO                     TestAllTypes_NestedEnum = 1
	TestAllTypes_BAR                     TestAllTypes_NestedEnum = 2
	TestAllTypes_BAZ                     TestAllTypes_NestedEnum = 3
	TestAllTypes_NEG                     TestAllTypes_NestedEnum = -1
)

var TestAllTypes_NestedEnum_name = map[int]string{
	0:  "NESTED_ENUM_UNSPECIFIED",
	1:  "FOO",
	2:  "BAR",
	3:  "BAZ",
	-1: "NEG",
}
var TestAllTypes_NestedEnum_value = map[string]int{
	"NESTED_ENUM_UNSPECIFIED": 0,
	"FOO": 1,
	"BAR": 2,
	"BAZ": 3,
	"NEG": -1,
}

func (x TestAllTypes_NestedEnum) String() string {
	return TestAllTypes_NestedEnum_name[int(x)]
}

// This proto includes every type of field in both singular and repeated
// forms.
type TestAllTypes struct {
	// Singular
	SingleInt32           int32
	SingleInt64           int64
	SingleUint32          uint32
	SingleUint64          uint64
	SingleSint32          int32
	SingleSint64          int64
	SingleFixed32         uint32
	SingleFixed64         uint64
	SingleSfixed32        int32
	SingleSfixed64        int64
	SingleFloat           float32
	SingleDouble          float64
	SingleBool            bool
	SingleString          string
	SingleBytes           []byte
	SingleImportedMessage *multitest2.Multi1
	SingleNestedMessage   *TestAllTypes_NestedMessage
	SingleForeignMessage  *ForeignMessage
	SingleNestedEnum      TestAllTypes_NestedEnum
	SingleForeignEnum     ForeignEnum
	// Repeated
	RepeatedInt32           []int32
	RepeatedInt64           []int64
	RepeatedUint32          []uint32
	RepeatedUint64          []uint64
	RepeatedSint32          []int32
	RepeatedSint64          []int64
	RepeatedFixed32         []uint32
	RepeatedFixed64         []uint64
	RepeatedSfixed32        []int32
	RepeatedSfixed64        []int64
	RepeatedFloat           []float32
	RepeatedDouble          []float64
	RepeatedBool            []bool
	RepeatedString          []string
	RepeatedBytes           [][]byte
	RepeatedImportedMessage []*multitest2.Multi1
	RepeatedNestedMessage   []*TestAllTypes_NestedMessage
	RepeatedForeignMessage  []*ForeignMessage
	RepeatedNestedEnum      []TestAllTypes_NestedEnum
	RepeatedForeignEnum     []ForeignEnum
	// For oneof test
	//
	// Types that are valid to be assigned to OneofField:
	//	*TestAllTypes_OneofUint32
	//	*TestAllTypes_OneofNestedMessage
	//	*TestAllTypes_OneofString
	//	*TestAllTypes_OneofBytes
	//	*TestAllTypes_OneofImportedMessage
	OneofField isTestAllTypes_OneofField
}

// isTestAllTypes_OneofField is used to distinguish types assignable to OneofField
type isTestAllTypes_OneofField interface{ isTestAllTypes_OneofField() }

// TestAllTypes_OneofUint32 is assignable to OneofField
type TestAllTypes_OneofUint32 struct {
	OneofUint32 uint32
}

// TestAllTypes_OneofNestedMessage is assignable to OneofField
type TestAllTypes_OneofNestedMessage struct {
	OneofNestedMessage *TestAllTypes_NestedMessage
}

// TestAllTypes_OneofString is assignable to OneofField
type TestAllTypes_OneofString struct {
	OneofString string
}

// TestAllTypes_OneofBytes is assignable to OneofField
type TestAllTypes_OneofBytes struct {
	OneofBytes []byte
}

// TestAllTypes_OneofImportedMessage is assignable to OneofField
type TestAllTypes_OneofImportedMessage struct {
	OneofImportedMessage *multitest2.Multi1
}

func (*TestAllTypes_OneofUint32) isTestAllTypes_OneofField()          {}
func (*TestAllTypes_OneofNestedMessage) isTestAllTypes_OneofField()   {}
func (*TestAllTypes_OneofString) isTestAllTypes_OneofField()          {}
func (*TestAllTypes_OneofBytes) isTestAllTypes_OneofField()           {}
func (*TestAllTypes_OneofImportedMessage) isTestAllTypes_OneofField() {}

// GetOneofField gets the OneofField of the TestAllTypes.
func (m *TestAllTypes) GetOneofField() (x isTestAllTypes_OneofField) {
	if m == nil {
		return x
	}
	return m.OneofField
}

// GetSingleInt32 gets the SingleInt32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleInt32() (x int32) {
	if m == nil {
		return x
	}
	return m.SingleInt32
}

// GetSingleInt64 gets the SingleInt64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleInt64() (x int64) {
	if m == nil {
		return x
	}
	return m.SingleInt64
}

// GetSingleUint32 gets the SingleUint32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleUint32() (x uint32) {
	if m == nil {
		return x
	}
	return m.SingleUint32
}

// GetSingleUint64 gets the SingleUint64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleUint64() (x uint64) {
	if m == nil {
		return x
	}
	return m.SingleUint64
}

// GetSingleSint32 gets the SingleSint32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSint32() (x int32) {
	if m == nil {
		return x
	}
	return m.SingleSint32
}

// GetSingleSint64 gets the SingleSint64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSint64() (x int64) {
	if m == nil {
		return x
	}
	return m.SingleSint64
}

// GetSingleFixed32 gets the SingleFixed32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleFixed32() (x uint32) {
	if m == nil {
		return x
	}
	return m.SingleFixed32
}

// GetSingleFixed64 gets the SingleFixed64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleFixed64() (x uint64) {
	if m == nil {
		return x
	}
	return m.SingleFixed64
}

// GetSingleSfixed32 gets the SingleSfixed32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSfixed32() (x int32) {
	if m == nil {
		return x
	}
	return m.SingleSfixed32
}

// GetSingleSfixed64 gets the SingleSfixed64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSfixed64() (x int64) {
	if m == nil {
		return x
	}
	return m.SingleSfixed64
}

// GetSingleFloat gets the SingleFloat of the TestAllTypes.
func (m *TestAllTypes) GetSingleFloat() (x float32) {
	if m == nil {
		return x
	}
	return m.SingleFloat
}

// GetSingleDouble gets the SingleDouble of the TestAllTypes.
func (m *TestAllTypes) GetSingleDouble() (x float64) {
	if m == nil {
		return x
	}
	return m.SingleDouble
}

// GetSingleBool gets the SingleBool of the TestAllTypes.
func (m *TestAllTypes) GetSingleBool() (x bool) {
	if m == nil {
		return x
	}
	return m.SingleBool
}

// GetSingleString gets the SingleString of the TestAllTypes.
func (m *TestAllTypes) GetSingleString() (x string) {
	if m == nil {
		return x
	}
	return m.SingleString
}

// GetSingleBytes gets the SingleBytes of the TestAllTypes.
func (m *TestAllTypes) GetSingleBytes() (x []byte) {
	if m == nil {
		return x
	}
	return m.SingleBytes
}

// GetSingleImportedMessage gets the SingleImportedMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleImportedMessage() (x *multitest2.Multi1) {
	if m == nil {
		return x
	}
	return m.SingleImportedMessage
}

// GetSingleNestedMessage gets the SingleNestedMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleNestedMessage() (x *TestAllTypes_NestedMessage) {
	if m == nil {
		return x
	}
	return m.SingleNestedMessage
}

// GetSingleForeignMessage gets the SingleForeignMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleForeignMessage() (x *ForeignMessage) {
	if m == nil {
		return x
	}
	return m.SingleForeignMessage
}

// GetSingleNestedEnum gets the SingleNestedEnum of the TestAllTypes.
func (m *TestAllTypes) GetSingleNestedEnum() (x TestAllTypes_NestedEnum) {
	if m == nil {
		return x
	}
	return m.SingleNestedEnum
}

// GetSingleForeignEnum gets the SingleForeignEnum of the TestAllTypes.
func (m *TestAllTypes) GetSingleForeignEnum() (x ForeignEnum) {
	if m == nil {
		return x
	}
	return m.SingleForeignEnum
}

// GetRepeatedInt32 gets the RepeatedInt32 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedInt32() (x []int32) {
	if m == nil {
		return x
	}
	return m.RepeatedInt32
}

// GetRepeatedInt64 gets the RepeatedInt64 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedInt64() (x []int64) {
	if m == nil {
		return x
	}
	return m.RepeatedInt64
}

// GetRepeatedUint32 gets the RepeatedUint32 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedUint32() (x []uint32) {
	if m == nil {
		return x
	}
	return m.RepeatedUint32
}

// GetRepeatedUint64 gets the RepeatedUint64 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedUint64() (x []uint64) {
	if m == nil {
		return x
	}
	return m.RepeatedUint64
}

// GetRepeatedSint32 gets the RepeatedSint32 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedSint32() (x []int32) {
	if m == nil {
		return x
	}
	return m.RepeatedSint32
}

// GetRepeatedSint64 gets the RepeatedSint64 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedSint64() (x []int64) {
	if m == nil {
		return x
	}
	return m.RepeatedSint64
}

// GetRepeatedFixed32 gets the RepeatedFixed32 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedFixed32() (x []uint32) {
	if m == nil {
		return x
	}
	return m.RepeatedFixed32
}

// GetRepeatedFixed64 gets the RepeatedFixed64 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedFixed64() (x []uint64) {
	if m == nil {
		return x
	}
	return m.RepeatedFixed64
}

// GetRepeatedSfixed32 gets the RepeatedSfixed32 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedSfixed32() (x []int32) {
	if m == nil {
		return x
	}
	return m.RepeatedSfixed32
}

// GetRepeatedSfixed64 gets the RepeatedSfixed64 of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedSfixed64() (x []int64) {
	if m == nil {
		return x
	}
	return m.RepeatedSfixed64
}

// GetRepeatedFloat gets the RepeatedFloat of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedFloat() (x []float32) {
	if m == nil {
		return x
	}
	return m.RepeatedFloat
}

// GetRepeatedDouble gets the RepeatedDouble of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedDouble() (x []float64) {
	if m == nil {
		return x
	}
	return m.RepeatedDouble
}

// GetRepeatedBool gets the RepeatedBool of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedBool() (x []bool) {
	if m == nil {
		return x
	}
	return m.RepeatedBool
}

// GetRepeatedString gets the RepeatedString of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedString() (x []string) {
	if m == nil {
		return x
	}
	return m.RepeatedString
}

// GetRepeatedBytes gets the RepeatedBytes of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedBytes() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.RepeatedBytes
}

// GetRepeatedImportedMessage gets the RepeatedImportedMessage of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedImportedMessage() (x []*multitest2.Multi1) {
	if m == nil {
		return x
	}
	return m.RepeatedImportedMessage
}

// GetRepeatedNestedMessage gets the RepeatedNestedMessage of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedNestedMessage() (x []*TestAllTypes_NestedMessage) {
	if m == nil {
		return x
	}
	return m.RepeatedNestedMessage
}

// GetRepeatedForeignMessage gets the RepeatedForeignMessage of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedForeignMessage() (x []*ForeignMessage) {
	if m == nil {
		return x
	}
	return m.RepeatedForeignMessage
}

// GetRepeatedNestedEnum gets the RepeatedNestedEnum of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedNestedEnum() (x []TestAllTypes_NestedEnum) {
	if m == nil {
		return x
	}
	return m.RepeatedNestedEnum
}

// GetRepeatedForeignEnum gets the RepeatedForeignEnum of the TestAllTypes.
func (m *TestAllTypes) GetRepeatedForeignEnum() (x []ForeignEnum) {
	if m == nil {
		return x
	}
	return m.RepeatedForeignEnum
}

// GetOneofUint32 gets the OneofUint32 of the TestAllTypes.
func (m *TestAllTypes) GetOneofUint32() (x uint32) {
	if v, ok := m.GetOneofField().(*TestAllTypes_OneofUint32); ok {
		return v.OneofUint32
	}
	return x
}

// GetOneofNestedMessage gets the OneofNestedMessage of the TestAllTypes.
func (m *TestAllTypes) GetOneofNestedMessage() (x *TestAllTypes_NestedMessage) {
	if v, ok := m.GetOneofField().(*TestAllTypes_OneofNestedMessage); ok {
		return v.OneofNestedMessage
	}
	return x
}

// GetOneofString gets the OneofString of the TestAllTypes.
func (m *TestAllTypes) GetOneofString() (x string) {
	if v, ok := m.GetOneofField().(*TestAllTypes_OneofString); ok {
		return v.OneofString
	}
	return x
}

// GetOneofBytes gets the OneofBytes of the TestAllTypes.
func (m *TestAllTypes) GetOneofBytes() (x []byte) {
	if v, ok := m.GetOneofField().(*TestAllTypes_OneofBytes); ok {
		return v.OneofBytes
	}
	return x
}

// GetOneofImportedMessage gets the OneofImportedMessage of the TestAllTypes.
func (m *TestAllTypes) GetOneofImportedMessage() (x *multitest2.Multi1) {
	if v, ok := m.GetOneofField().(*TestAllTypes_OneofImportedMessage); ok {
		return v.OneofImportedMessage
	}
	return x
}

// MarshalToWriter marshals TestAllTypes to the provided writer.
func (m *TestAllTypes) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.OneofField.(type) {
	case *TestAllTypes_OneofUint32:
		if t.OneofUint32 != 0 {
			writer.WriteUint32(111, t.OneofUint32)
		}
	case *TestAllTypes_OneofNestedMessage:
		if t.OneofNestedMessage != nil {
			writer.WriteMessage(112, func() {
				t.OneofNestedMessage.MarshalToWriter(writer)
			})
		}
	case *TestAllTypes_OneofString:
		if len(t.OneofString) > 0 {
			writer.WriteString(113, t.OneofString)
		}
	case *TestAllTypes_OneofBytes:
		if len(t.OneofBytes) > 0 {
			writer.WriteBytes(114, t.OneofBytes)
		}
	case *TestAllTypes_OneofImportedMessage:
		if t.OneofImportedMessage != nil {
			writer.WriteMessage(115, func() {
				t.OneofImportedMessage.MarshalToWriter(writer)
			})
		}
	}

	if m.SingleInt32 != 0 {
		writer.WriteInt32(1, m.SingleInt32)
	}

	if m.SingleInt64 != 0 {
		writer.WriteInt64(2, m.SingleInt64)
	}

	if m.SingleUint32 != 0 {
		writer.WriteUint32(3, m.SingleUint32)
	}

	if m.SingleUint64 != 0 {
		writer.WriteUint64(4, m.SingleUint64)
	}

	if m.SingleSint32 != 0 {
		writer.WriteSint32(5, m.SingleSint32)
	}

	if m.SingleSint64 != 0 {
		writer.WriteSint64(6, m.SingleSint64)
	}

	if m.SingleFixed32 != 0 {
		writer.WriteFixed32(7, m.SingleFixed32)
	}

	if m.SingleFixed64 != 0 {
		writer.WriteFixed64(8, m.SingleFixed64)
	}

	if m.SingleSfixed32 != 0 {
		writer.WriteSfixed32(9, m.SingleSfixed32)
	}

	if m.SingleSfixed64 != 0 {
		writer.WriteSfixed64(10, m.SingleSfixed64)
	}

	if m.SingleFloat != 0 {
		writer.WriteFloat32(11, m.SingleFloat)
	}

	if m.SingleDouble != 0 {
		writer.WriteFloat64(12, m.SingleDouble)
	}

	if m.SingleBool {
		writer.WriteBool(13, m.SingleBool)
	}

	if len(m.SingleString) > 0 {
		writer.WriteString(14, m.SingleString)
	}

	if len(m.SingleBytes) > 0 {
		writer.WriteBytes(15, m.SingleBytes)
	}

	if m.SingleImportedMessage != nil {
		writer.WriteMessage(16, func() {
			m.SingleImportedMessage.MarshalToWriter(writer)
		})
	}

	if m.SingleNestedMessage != nil {
		writer.WriteMessage(18, func() {
			m.SingleNestedMessage.MarshalToWriter(writer)
		})
	}

	if m.SingleForeignMessage != nil {
		writer.WriteMessage(19, func() {
			m.SingleForeignMessage.MarshalToWriter(writer)
		})
	}

	if int(m.SingleNestedEnum) != 0 {
		writer.WriteEnum(21, int(m.SingleNestedEnum))
	}

	if int(m.SingleForeignEnum) != 0 {
		writer.WriteEnum(22, int(m.SingleForeignEnum))
	}

	if len(m.RepeatedInt32) > 0 {
		writer.WriteInt32Slice(31, m.RepeatedInt32)
	}

	if len(m.RepeatedInt64) > 0 {
		writer.WriteInt64Slice(32, m.RepeatedInt64)
	}

	if len(m.RepeatedUint32) > 0 {
		writer.WriteUint32Slice(33, m.RepeatedUint32)
	}

	if len(m.RepeatedUint64) > 0 {
		writer.WriteUint64Slice(34, m.RepeatedUint64)
	}

	if len(m.RepeatedSint32) > 0 {
		writer.WriteSint32Slice(35, m.RepeatedSint32)
	}

	if len(m.RepeatedSint64) > 0 {
		writer.WriteSint64Slice(36, m.RepeatedSint64)
	}

	if len(m.RepeatedFixed32) > 0 {
		writer.WriteFixed32Slice(37, m.RepeatedFixed32)
	}

	if len(m.RepeatedFixed64) > 0 {
		writer.WriteFixed64Slice(38, m.RepeatedFixed64)
	}

	if len(m.RepeatedSfixed32) > 0 {
		writer.WriteSfixed32Slice(39, m.RepeatedSfixed32)
	}

	if len(m.RepeatedSfixed64) > 0 {
		writer.WriteSfixed64Slice(40, m.RepeatedSfixed64)
	}

	if len(m.RepeatedFloat) > 0 {
		writer.WriteFloat32Slice(41, m.RepeatedFloat)
	}

	if len(m.RepeatedDouble) > 0 {
		writer.WriteFloat64Slice(42, m.RepeatedDouble)
	}

	if len(m.RepeatedBool) > 0 {
		writer.WriteBoolSlice(43, m.RepeatedBool)
	}

	for _, val := range m.RepeatedString {
		writer.WriteString(44, val)
	}

	for _, val := range m.RepeatedBytes {
		writer.WriteBytes(45, val)
	}

	for _, msg := range m.RepeatedImportedMessage {
		writer.WriteMessage(46, func() {
			msg.MarshalToWriter(writer)
		})
	}

	for _, msg := range m.RepeatedNestedMessage {
		writer.WriteMessage(48, func() {
			msg.MarshalToWriter(writer)
		})
	}

	for _, msg := range m.RepeatedForeignMessage {
		writer.WriteMessage(49, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if len(m.RepeatedNestedEnum) > 0 {
		var ints []int
		for _, enum := range m.RepeatedNestedEnum {
			ints = append(ints, int(enum))
		}
		writer.WriteEnumSlice(51, ints)
	}

	if len(m.RepeatedForeignEnum) > 0 {
		var ints []int
		for _, enum := range m.RepeatedForeignEnum {
			ints = append(ints, int(enum))
		}
		writer.WriteEnumSlice(52, ints)
	}

	return
}

// Marshal marshals TestAllTypes to a slice of bytes.
func (m *TestAllTypes) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TestAllTypes from the provided reader.
func (m *TestAllTypes) UnmarshalFromReader(reader jspb.Reader) *TestAllTypes {
	for reader.Next() {
		if m == nil {
			m = &TestAllTypes{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SingleInt32 = reader.ReadInt32()
		case 2:
			m.SingleInt64 = reader.ReadInt64()
		case 3:
			m.SingleUint32 = reader.ReadUint32()
		case 4:
			m.SingleUint64 = reader.ReadUint64()
		case 5:
			m.SingleSint32 = reader.ReadSint32()
		case 6:
			m.SingleSint64 = reader.ReadSint64()
		case 7:
			m.SingleFixed32 = reader.ReadFixed32()
		case 8:
			m.SingleFixed64 = reader.ReadFixed64()
		case 9:
			m.SingleSfixed32 = reader.ReadSfixed32()
		case 10:
			m.SingleSfixed64 = reader.ReadSfixed64()
		case 11:
			m.SingleFloat = reader.ReadFloat32()
		case 12:
			m.SingleDouble = reader.ReadFloat64()
		case 13:
			m.SingleBool = reader.ReadBool()
		case 14:
			m.SingleString = reader.ReadString()
		case 15:
			m.SingleBytes = reader.ReadBytes()
		case 16:
			reader.ReadMessage(func() {
				m.SingleImportedMessage = m.SingleImportedMessage.UnmarshalFromReader(reader)
			})
		case 18:
			reader.ReadMessage(func() {
				m.SingleNestedMessage = m.SingleNestedMessage.UnmarshalFromReader(reader)
			})
		case 19:
			reader.ReadMessage(func() {
				m.SingleForeignMessage = m.SingleForeignMessage.UnmarshalFromReader(reader)
			})
		case 21:
			m.SingleNestedEnum = TestAllTypes_NestedEnum(reader.ReadEnum())
		case 22:
			m.SingleForeignEnum = ForeignEnum(reader.ReadEnum())
		case 31:
			m.RepeatedInt32 = reader.ReadInt32Slice()
		case 32:
			m.RepeatedInt64 = reader.ReadInt64Slice()
		case 33:
			m.RepeatedUint32 = reader.ReadUint32Slice()
		case 34:
			m.RepeatedUint64 = reader.ReadUint64Slice()
		case 35:
			m.RepeatedSint32 = reader.ReadSint32Slice()
		case 36:
			m.RepeatedSint64 = reader.ReadSint64Slice()
		case 37:
			m.RepeatedFixed32 = reader.ReadFixed32Slice()
		case 38:
			m.RepeatedFixed64 = reader.ReadFixed64Slice()
		case 39:
			m.RepeatedSfixed32 = reader.ReadSfixed32Slice()
		case 40:
			m.RepeatedSfixed64 = reader.ReadSfixed64Slice()
		case 41:
			m.RepeatedFloat = reader.ReadFloat32Slice()
		case 42:
			m.RepeatedDouble = reader.ReadFloat64Slice()
		case 43:
			m.RepeatedBool = reader.ReadBoolSlice()
		case 44:
			m.RepeatedString = append(m.RepeatedString, reader.ReadString())
		case 45:
			m.RepeatedBytes = append(m.RepeatedBytes, reader.ReadBytes())
		case 46:
			reader.ReadMessage(func() {
				m.RepeatedImportedMessage = append(m.RepeatedImportedMessage, new(multitest2.Multi1).UnmarshalFromReader(reader))
			})
		case 48:
			reader.ReadMessage(func() {
				m.RepeatedNestedMessage = append(m.RepeatedNestedMessage, new(TestAllTypes_NestedMessage).UnmarshalFromReader(reader))
			})
		case 49:
			reader.ReadMessage(func() {
				m.RepeatedForeignMessage = append(m.RepeatedForeignMessage, new(ForeignMessage).UnmarshalFromReader(reader))
			})
		case 51:
			values := reader.ReadEnumSlice()
			for _, enum := range values {
				m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, TestAllTypes_NestedEnum(enum))
			}
		case 52:
			values := reader.ReadEnumSlice()
			for _, enum := range values {
				m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, ForeignEnum(enum))
			}
		case 111:
			m.OneofField = &TestAllTypes_OneofUint32{
				OneofUint32: reader.ReadUint32(),
			}
		case 112:
			reader.ReadMessage(func() {
				m.OneofField = &TestAllTypes_OneofNestedMessage{
					OneofNestedMessage: new(TestAllTypes_NestedMessage).UnmarshalFromReader(reader),
				}
			})
		case 113:
			m.OneofField = &TestAllTypes_OneofString{
				OneofString: reader.ReadString(),
			}
		case 114:
			m.OneofField = &TestAllTypes_OneofBytes{
				OneofBytes: reader.ReadBytes(),
			}
		case 115:
			reader.ReadMessage(func() {
				m.OneofField = &TestAllTypes_OneofImportedMessage{
					OneofImportedMessage: new(multitest2.Multi1).UnmarshalFromReader(reader),
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TestAllTypes from a slice of bytes.
func (m *TestAllTypes) Unmarshal(rawBytes []byte) (*TestAllTypes, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type TestAllTypes_NestedMessage struct {
	B int32
}

// GetB gets the B of the TestAllTypes_NestedMessage.
func (m *TestAllTypes_NestedMessage) GetB() (x int32) {
	if m == nil {
		return x
	}
	return m.B
}

// MarshalToWriter marshals TestAllTypes_NestedMessage to the provided writer.
func (m *TestAllTypes_NestedMessage) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.B != 0 {
		writer.WriteInt32(1, m.B)
	}

	return
}

// Marshal marshals TestAllTypes_NestedMessage to a slice of bytes.
func (m *TestAllTypes_NestedMessage) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TestAllTypes_NestedMessage from the provided reader.
func (m *TestAllTypes_NestedMessage) UnmarshalFromReader(reader jspb.Reader) *TestAllTypes_NestedMessage {
	for reader.Next() {
		if m == nil {
			m = &TestAllTypes_NestedMessage{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.B = reader.ReadInt32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TestAllTypes_NestedMessage from a slice of bytes.
func (m *TestAllTypes_NestedMessage) Unmarshal(rawBytes []byte) (*TestAllTypes_NestedMessage, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// This proto includes a recusively nested message.
type NestedTestAllTypes struct {
	Child         *NestedTestAllTypes
	Payload       *TestAllTypes
	RepeatedChild []*NestedTestAllTypes
}

// GetChild gets the Child of the NestedTestAllTypes.
func (m *NestedTestAllTypes) GetChild() (x *NestedTestAllTypes) {
	if m == nil {
		return x
	}
	return m.Child
}

// GetPayload gets the Payload of the NestedTestAllTypes.
func (m *NestedTestAllTypes) GetPayload() (x *TestAllTypes) {
	if m == nil {
		return x
	}
	return m.Payload
}

// GetRepeatedChild gets the RepeatedChild of the NestedTestAllTypes.
func (m *NestedTestAllTypes) GetRepeatedChild() (x []*NestedTestAllTypes) {
	if m == nil {
		return x
	}
	return m.RepeatedChild
}

// MarshalToWriter marshals NestedTestAllTypes to the provided writer.
func (m *NestedTestAllTypes) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Child != nil {
		writer.WriteMessage(1, func() {
			m.Child.MarshalToWriter(writer)
		})
	}

	if m.Payload != nil {
		writer.WriteMessage(2, func() {
			m.Payload.MarshalToWriter(writer)
		})
	}

	for _, msg := range m.RepeatedChild {
		writer.WriteMessage(3, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals NestedTestAllTypes to a slice of bytes.
func (m *NestedTestAllTypes) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a NestedTestAllTypes from the provided reader.
func (m *NestedTestAllTypes) UnmarshalFromReader(reader jspb.Reader) *NestedTestAllTypes {
	for reader.Next() {
		if m == nil {
			m = &NestedTestAllTypes{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Child = m.Child.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Payload = m.Payload.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.RepeatedChild = append(m.RepeatedChild, new(NestedTestAllTypes).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a NestedTestAllTypes from a slice of bytes.
func (m *NestedTestAllTypes) Unmarshal(rawBytes []byte) (*NestedTestAllTypes, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Define these after TestAllTypes to make sure the compiler can handle
// that.
type ForeignMessage struct {
	C int32
}

// GetC gets the C of the ForeignMessage.
func (m *ForeignMessage) GetC() (x int32) {
	if m == nil {
		return x
	}
	return m.C
}

// MarshalToWriter marshals ForeignMessage to the provided writer.
func (m *ForeignMessage) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.C != 0 {
		writer.WriteInt32(1, m.C)
	}

	return
}

// Marshal marshals ForeignMessage to a slice of bytes.
func (m *ForeignMessage) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ForeignMessage from the provided reader.
func (m *ForeignMessage) UnmarshalFromReader(reader jspb.Reader) *ForeignMessage {
	for reader.Next() {
		if m == nil {
			m = &ForeignMessage{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.C = reader.ReadInt32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ForeignMessage from a slice of bytes.
func (m *ForeignMessage) Unmarshal(rawBytes []byte) (*ForeignMessage, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Tests maps.
type TestMap struct {
	MapInt32Int32           map[int32]int32
	MapInt64Int64           map[int64]int64
	MapUint32Uint32         map[uint32]uint32
	MapUint64Uint64         map[uint64]uint64
	MapSint32Sint32         map[int32]int32
	MapSint64Sint64         map[int64]int64
	MapFixed32Fixed32       map[uint32]uint32
	MapFixed64Fixed64       map[uint64]uint64
	MapSfixed32Sfixed32     map[int32]int32
	MapSfixed64Sfixed64     map[int64]int64
	MapInt32Float           map[int32]float32
	MapInt32Double          map[int32]float64
	MapBoolBool             map[bool]bool
	MapStringString         map[string]string
	MapInt32Bytes           map[int32][]byte
	MapInt32Enum            map[int32]MapEnum
	MapInt32ForeignMessage  map[int32]*ForeignMessage
	MapInt32ImportedMessage map[int32]*multitest2.Multi1
}

// GetMapInt32Int32 gets the MapInt32Int32 of the TestMap.
func (m *TestMap) GetMapInt32Int32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	return m.MapInt32Int32
}

// GetMapInt64Int64 gets the MapInt64Int64 of the TestMap.
func (m *TestMap) GetMapInt64Int64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	return m.MapInt64Int64
}

// GetMapUint32Uint32 gets the MapUint32Uint32 of the TestMap.
func (m *TestMap) GetMapUint32Uint32() (x map[uint32]uint32) {
	if m == nil {
		return x
	}
	return m.MapUint32Uint32
}

// GetMapUint64Uint64 gets the MapUint64Uint64 of the TestMap.
func (m *TestMap) GetMapUint64Uint64() (x map[uint64]uint64) {
	if m == nil {
		return x
	}
	return m.MapUint64Uint64
}

// GetMapSint32Sint32 gets the MapSint32Sint32 of the TestMap.
func (m *TestMap) GetMapSint32Sint32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	return m.MapSint32Sint32
}

// GetMapSint64Sint64 gets the MapSint64Sint64 of the TestMap.
func (m *TestMap) GetMapSint64Sint64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	return m.MapSint64Sint64
}

// GetMapFixed32Fixed32 gets the MapFixed32Fixed32 of the TestMap.
func (m *TestMap) GetMapFixed32Fixed32() (x map[uint32]uint32) {
	if m == nil {
		return x
	}
	return m.MapFixed32Fixed32
}

// GetMapFixed64Fixed64 gets the MapFixed64Fixed64 of the TestMap.
func (m *TestMap) GetMapFixed64Fixed64() (x map[uint64]uint64) {
	if m == nil {
		return x
	}
	return m.MapFixed64Fixed64
}

// GetMapSfixed32Sfixed32 gets the MapSfixed32Sfixed32 of the TestMap.
func (m *TestMap) GetMapSfixed32Sfixed32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	return m.MapSfixed32Sfixed32
}

// GetMapSfixed64Sfixed64 gets the MapSfixed64Sfixed64 of the TestMap.
func (m *TestMap) GetMapSfixed64Sfixed64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	return m.MapSfixed64Sfixed64
}

// GetMapInt32Float gets the MapInt32Float of the TestMap.
func (m *TestMap) GetMapInt32Float() (x map[int32]float32) {
	if m == nil {
		return x
	}
	return m.MapInt32Float
}

// GetMapInt32Double gets the MapInt32Double of the TestMap.
func (m *TestMap) GetMapInt32Double() (x map[int32]float64) {
	if m == nil {
		return x
	}
	return m.MapInt32Double
}

// GetMapBoolBool gets the MapBoolBool of the TestMap.
func (m *TestMap) GetMapBoolBool() (x map[bool]bool) {
	if m == nil {
		return x
	}
	return m.MapBoolBool
}

// GetMapStringString gets the MapStringString of the TestMap.
func (m *TestMap) GetMapStringString() (x map[string]string) {
	if m == nil {
		return x
	}
	return m.MapStringString
}

// GetMapInt32Bytes gets the MapInt32Bytes of the TestMap.
func (m *TestMap) GetMapInt32Bytes() (x map[int32][]byte) {
	if m == nil {
		return x
	}
	return m.MapInt32Bytes
}

// GetMapInt32Enum gets the MapInt32Enum of the TestMap.
func (m *TestMap) GetMapInt32Enum() (x map[int32]MapEnum) {
	if m == nil {
		return x
	}
	return m.MapInt32Enum
}

// GetMapInt32ForeignMessage gets the MapInt32ForeignMessage of the TestMap.
func (m *TestMap) GetMapInt32ForeignMessage() (x map[int32]*ForeignMessage) {
	if m == nil {
		return x
	}
	return m.MapInt32ForeignMessage
}

// GetMapInt32ImportedMessage gets the MapInt32ImportedMessage of the TestMap.
func (m *TestMap) GetMapInt32ImportedMessage() (x map[int32]*multitest2.Multi1) {
	if m == nil {
		return x
	}
	return m.MapInt32ImportedMessage
}

// MarshalToWriter marshals TestMap to the provided writer.
func (m *TestMap) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.MapInt32Int32) > 0 {
		for key, value := range m.MapInt32Int32 {
			writer.WriteMessage(1, func() {
				writer.WriteInt32(1, key)
				writer.WriteInt32(2, value)
			})
		}
	}

	if len(m.MapInt64Int64) > 0 {
		for key, value := range m.MapInt64Int64 {
			writer.WriteMessage(2, func() {
				writer.WriteInt64(1, key)
				writer.WriteInt64(2, value)
			})
		}
	}

	if len(m.MapUint32Uint32) > 0 {
		for key, value := range m.MapUint32Uint32 {
			writer.WriteMessage(3, func() {
				writer.WriteUint32(1, key)
				writer.WriteUint32(2, value)
			})
		}
	}

	if len(m.MapUint64Uint64) > 0 {
		for key, value := range m.MapUint64Uint64 {
			writer.WriteMessage(4, func() {
				writer.WriteUint64(1, key)
				writer.WriteUint64(2, value)
			})
		}
	}

	if len(m.MapSint32Sint32) > 0 {
		for key, value := range m.MapSint32Sint32 {
			writer.WriteMessage(5, func() {
				writer.WriteSint32(1, key)
				writer.WriteSint32(2, value)
			})
		}
	}

	if len(m.MapSint64Sint64) > 0 {
		for key, value := range m.MapSint64Sint64 {
			writer.WriteMessage(6, func() {
				writer.WriteSint64(1, key)
				writer.WriteSint64(2, value)
			})
		}
	}

	if len(m.MapFixed32Fixed32) > 0 {
		for key, value := range m.MapFixed32Fixed32 {
			writer.WriteMessage(7, func() {
				writer.WriteFixed32(1, key)
				writer.WriteFixed32(2, value)
			})
		}
	}

	if len(m.MapFixed64Fixed64) > 0 {
		for key, value := range m.MapFixed64Fixed64 {
			writer.WriteMessage(8, func() {
				writer.WriteFixed64(1, key)
				writer.WriteFixed64(2, value)
			})
		}
	}

	if len(m.MapSfixed32Sfixed32) > 0 {
		for key, value := range m.MapSfixed32Sfixed32 {
			writer.WriteMessage(9, func() {
				writer.WriteSfixed32(1, key)
				writer.WriteSfixed32(2, value)
			})
		}
	}

	if len(m.MapSfixed64Sfixed64) > 0 {
		for key, value := range m.MapSfixed64Sfixed64 {
			writer.WriteMessage(10, func() {
				writer.WriteSfixed64(1, key)
				writer.WriteSfixed64(2, value)
			})
		}
	}

	if len(m.MapInt32Float) > 0 {
		for key, value := range m.MapInt32Float {
			writer.WriteMessage(11, func() {
				writer.WriteInt32(1, key)
				writer.WriteFloat32(2, value)
			})
		}
	}

	if len(m.MapInt32Double) > 0 {
		for key, value := range m.MapInt32Double {
			writer.WriteMessage(12, func() {
				writer.WriteInt32(1, key)
				writer.WriteFloat64(2, value)
			})
		}
	}

	if len(m.MapBoolBool) > 0 {
		for key, value := range m.MapBoolBool {
			writer.WriteMessage(13, func() {
				writer.WriteBool(1, key)
				writer.WriteBool(2, value)
			})
		}
	}

	if len(m.MapStringString) > 0 {
		for key, value := range m.MapStringString {
			writer.WriteMessage(14, func() {
				writer.WriteString(1, key)
				writer.WriteString(2, value)
			})
		}
	}

	if len(m.MapInt32Bytes) > 0 {
		for key, value := range m.MapInt32Bytes {
			writer.WriteMessage(15, func() {
				writer.WriteInt32(1, key)
				writer.WriteBytes(2, value)
			})
		}
	}

	if len(m.MapInt32Enum) > 0 {
		for key, value := range m.MapInt32Enum {
			writer.WriteMessage(16, func() {
				writer.WriteInt32(1, key)
				writer.WriteEnum(2, int(value))
			})
		}
	}

	if len(m.MapInt32ForeignMessage) > 0 {
		for key, value := range m.MapInt32ForeignMessage {
			writer.WriteMessage(17, func() {
				writer.WriteInt32(1, key)
				writer.WriteMessage(2, func() {
					value.MarshalToWriter(writer)
				})
			})
		}
	}

	if len(m.MapInt32ImportedMessage) > 0 {
		for key, value := range m.MapInt32ImportedMessage {
			writer.WriteMessage(18, func() {
				writer.WriteInt32(1, key)
				writer.WriteMessage(2, func() {
					value.MarshalToWriter(writer)
				})
			})
		}
	}

	return
}

// Marshal marshals TestMap to a slice of bytes.
func (m *TestMap) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TestMap from the provided reader.
func (m *TestMap) UnmarshalFromReader(reader jspb.Reader) *TestMap {
	for reader.Next() {
		if m == nil {
			m = &TestMap{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			if m.MapInt32Int32 == nil {
				m.MapInt32Int32 = map[int32]int32{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value int32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						value = reader.ReadInt32()
					}
					m.MapInt32Int32[key] = value
				}
			})
		case 2:
			if m.MapInt64Int64 == nil {
				m.MapInt64Int64 = map[int64]int64{}
			}
			reader.ReadMessage(func() {
				var key int64
				var value int64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt64()
					case 2:
						value = reader.ReadInt64()
					}
					m.MapInt64Int64[key] = value
				}
			})
		case 3:
			if m.MapUint32Uint32 == nil {
				m.MapUint32Uint32 = map[uint32]uint32{}
			}
			reader.ReadMessage(func() {
				var key uint32
				var value uint32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadUint32()
					case 2:
						value = reader.ReadUint32()
					}
					m.MapUint32Uint32[key] = value
				}
			})
		case 4:
			if m.MapUint64Uint64 == nil {
				m.MapUint64Uint64 = map[uint64]uint64{}
			}
			reader.ReadMessage(func() {
				var key uint64
				var value uint64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadUint64()
					case 2:
						value = reader.ReadUint64()
					}
					m.MapUint64Uint64[key] = value
				}
			})
		case 5:
			if m.MapSint32Sint32 == nil {
				m.MapSint32Sint32 = map[int32]int32{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value int32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadSint32()
					case 2:
						value = reader.ReadSint32()
					}
					m.MapSint32Sint32[key] = value
				}
			})
		case 6:
			if m.MapSint64Sint64 == nil {
				m.MapSint64Sint64 = map[int64]int64{}
			}
			reader.ReadMessage(func() {
				var key int64
				var value int64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadSint64()
					case 2:
						value = reader.ReadSint64()
					}
					m.MapSint64Sint64[key] = value
				}
			})
		case 7:
			if m.MapFixed32Fixed32 == nil {
				m.MapFixed32Fixed32 = map[uint32]uint32{}
			}
			reader.ReadMessage(func() {
				var key uint32
				var value uint32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadFixed32()
					case 2:
						value = reader.ReadFixed32()
					}
					m.MapFixed32Fixed32[key] = value
				}
			})
		case 8:
			if m.MapFixed64Fixed64 == nil {
				m.MapFixed64Fixed64 = map[uint64]uint64{}
			}
			reader.ReadMessage(func() {
				var key uint64
				var value uint64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadFixed64()
					case 2:
						value = reader.ReadFixed64()
					}
					m.MapFixed64Fixed64[key] = value
				}
			})
		case 9:
			if m.MapSfixed32Sfixed32 == nil {
				m.MapSfixed32Sfixed32 = map[int32]int32{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value int32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadSfixed32()
					case 2:
						value = reader.ReadSfixed32()
					}
					m.MapSfixed32Sfixed32[key] = value
				}
			})
		case 10:
			if m.MapSfixed64Sfixed64 == nil {
				m.MapSfixed64Sfixed64 = map[int64]int64{}
			}
			reader.ReadMessage(func() {
				var key int64
				var value int64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadSfixed64()
					case 2:
						value = reader.ReadSfixed64()
					}
					m.MapSfixed64Sfixed64[key] = value
				}
			})
		case 11:
			if m.MapInt32Float == nil {
				m.MapInt32Float = map[int32]float32{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value float32
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						value = reader.ReadFloat32()
					}
					m.MapInt32Float[key] = value
				}
			})
		case 12:
			if m.MapInt32Double == nil {
				m.MapInt32Double = map[int32]float64{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value float64
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						value = reader.ReadFloat64()
					}
					m.MapInt32Double[key] = value
				}
			})
		case 13:
			if m.MapBoolBool == nil {
				m.MapBoolBool = map[bool]bool{}
			}
			reader.ReadMessage(func() {
				var key bool
				var value bool
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadBool()
					case 2:
						value = reader.ReadBool()
					}
					m.MapBoolBool[key] = value
				}
			})
		case 14:
			if m.MapStringString == nil {
				m.MapStringString = map[string]string{}
			}
			reader.ReadMessage(func() {
				var key string
				var value string
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						value = reader.ReadString()
					}
					m.MapStringString[key] = value
				}
			})
		case 15:
			if m.MapInt32Bytes == nil {
				m.MapInt32Bytes = map[int32][]byte{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value []byte
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						value = reader.ReadBytes()
					}
					m.MapInt32Bytes[key] = value
				}
			})
		case 16:
			if m.MapInt32Enum == nil {
				m.MapInt32Enum = map[int32]MapEnum{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value MapEnum
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						value = MapEnum(reader.ReadEnum())
					}
					m.MapInt32Enum[key] = value
				}
			})
		case 17:
			if m.MapInt32ForeignMessage == nil {
				m.MapInt32ForeignMessage = map[int32]*ForeignMessage{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value *ForeignMessage
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						reader.ReadMessage(func() {
							value = new(ForeignMessage).UnmarshalFromReader(reader)
						})
					}
					m.MapInt32ForeignMessage[key] = value
				}
			})
		case 18:
			if m.MapInt32ImportedMessage == nil {
				m.MapInt32ImportedMessage = map[int32]*multitest2.Multi1{}
			}
			reader.ReadMessage(func() {
				var key int32
				var value *multitest2.Multi1
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadInt32()
					case 2:
						reader.ReadMessage(func() {
							value = new(multitest2.Multi1).UnmarshalFromReader(reader)
						})
					}
					m.MapInt32ImportedMessage[key] = value
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TestMap from a slice of bytes.
func (m *TestMap) Unmarshal(rawBytes []byte) (*TestMap, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for EchoService service

type EchoServiceClient interface {
	EchoAllTypes(ctx context.Context, in *TestAllTypes, opts ...grpcweb.CallOption) (*TestAllTypes, error)
	EchoMaps(ctx context.Context, in *TestMap, opts ...grpcweb.CallOption) (*TestMap, error)
}

type echoServiceClient struct {
	client *grpcweb.Client
}

// NewEchoServiceClient creates a new gRPC-Web client.
func NewEchoServiceClient(hostname string, opts ...grpcweb.DialOption) EchoServiceClient {
	return &echoServiceClient{
		client: grpcweb.NewClient(hostname, "types.EchoService", opts...),
	}
}

func (c *echoServiceClient) EchoAllTypes(ctx context.Context, in *TestAllTypes, opts ...grpcweb.CallOption) (*TestAllTypes, error) {
	resp, err := c.client.RPCCall(ctx, "EchoAllTypes", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(TestAllTypes).Unmarshal(resp)
}

func (c *echoServiceClient) EchoMaps(ctx context.Context, in *TestMap, opts ...grpcweb.CallOption) (*TestMap, error) {
	resp, err := c.client.RPCCall(ctx, "EchoMaps", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(TestMap).Unmarshal(resp)
}
